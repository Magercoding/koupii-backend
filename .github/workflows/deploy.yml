name: Deploy Production

on:
  push:
    branches: ["main"]
  workflow_dispatch:

env:
  REGISTRY_IMAGE: ghcr.io/magercoding/koupii-backend

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tag }}
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.3"
          extensions: mbstring, intl, pcntl, bcmath, zip, pdo_mysql, gd
          coverage: none

      - name: Cache Composer dependencies
        uses: actions/cache@v3
        with:
          path: vendor
          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: Install Composer dependencies
        run: composer install --no-interaction --prefer-dist --optimize-autoloader

      - name: Copy .env for testing
        run: cp .env.example .env

      - name: Generate application key
        run: php artisan key:generate

      - name: Run Tests (Production)
        id: tests
        run: |
          echo "## ðŸ§ª Running Tests (Production Build)" >> $GITHUB_STEP_SUMMARY
          php artisan test --stop-on-failure || echo "No tests found or tests skipped"
          echo "âœ… Tests completed!" >> $GITHUB_STEP_SUMMARY

      - name: Check Migration Status
        run: |
          echo "## ðŸ“Š Migration Status" >> $GITHUB_STEP_SUMMARY
          php artisan migrate:status --env=testing || echo "No migrations to check"

      - name: Set image tag
        id: meta
        run: echo "tag=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"

      - name: Log in to GitHub Container Registry
        run: echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ghcr.io -u "${{ secrets.REGISTRY_USERNAME }}" --password-stdin

      - name: Build and push image
        env:
          IMAGE_TAG: ${{ steps.meta.outputs.tag }}
        run: |
          docker build -f Dockerfile.backend -t "${REGISTRY_IMAGE}:${IMAGE_TAG}" .
          docker push "${REGISTRY_IMAGE}:${IMAGE_TAG}"
          docker tag "${REGISTRY_IMAGE}:${IMAGE_TAG}" "${REGISTRY_IMAGE}:latest"
          docker push "${REGISTRY_IMAGE}:latest"

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/main' }}
    env:
      IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.SSH_HOST_STAGING }}
          username: ${{ secrets.SSH_USER_STAGING }}
          key: ${{ secrets.SSH_KEY_STAGING }}
          envs: IMAGE_TAG,REGISTRY_IMAGE
          timeout: 60s
          command_timeout: 10m
          script: |
            set -e
            mkdir -p /srv/apps/koupii-backend
            cd /srv/apps/koupii-backend

            printf '%s\n' "${{ secrets.ENV_PRODUCTION }}" > .env.tmp
            if [ -f .env ]; then mv .env .env.backup; fi
            mv .env.tmp .env
            grep -v '^IMAGE_NAME=' .env > .env.tmp && mv .env.tmp .env
            echo "IMAGE_NAME=${REGISTRY_IMAGE}:${IMAGE_TAG}" >> .env
            if ! grep -q '^APP_BASE_PATH=' .env; then
              echo 'APP_BASE_PATH=/var/www/html' >> .env
            fi
            if ! grep -q '^APP_PORT=' .env; then
              echo 'APP_PORT=8081' >> .env
            fi
            if grep -q '^DB_HOST=' .env; then
              sed -i 's/^DB_HOST=.*/DB_HOST=koupii-mysql/' .env
            else
              echo 'DB_HOST=koupii-mysql' >> .env
            fi

            echo "Login registry"
            # Use directory in app folder that user owns, not /tmp/.docker
            mkdir -p .docker
            export DOCKER_CONFIG=$(pwd)/.docker
            chmod 700 .docker
            echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ghcr.io -u "${{ secrets.REGISTRY_USERNAME }}" --password-stdin

            # Debug: Show image name
            echo "Image name: ${REGISTRY_IMAGE}:${IMAGE_TAG}"
            echo "IMAGE_NAME from .env: $(grep IMAGE_NAME .env)"

            cat > docker-compose.yml << 'COMPOSEEOF'
            services:
              backend:
                image: ${REGISTRY_IMAGE}:${IMAGE_TAG}
                container_name: koupii-backend
                restart: unless-stopped
                env_file:
                  - .env
                depends_on:
                  mysql:
                    condition: service_healthy
                ports:
                  - "127.0.0.1:${APP_PORT:-8081}:80"
                volumes:
                  - storage:/var/www/html/storage
                  - logs:/var/www/html/storage/logs
                  - bootstrap-cache:/var/www/html/bootstrap/cache
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://127.0.0.1:80/api/health"]
                  interval: 30s
                  timeout: 5s
                  retries: 3
                  start_period: 30s
                deploy:
                  resources:
                    limits:
                      cpus: "2.0"
                      memory: 2048M
                    reservations:
                      cpus: "0.5"
                      memory: 1024M

              mysql:
                image: mysql:8.0
                container_name: koupii-mysql
                restart: unless-stopped
                environment:
                  MYSQL_DATABASE: ${DB_DATABASE:-koupii_production}
                  MYSQL_USER: ${DB_USERNAME:-koupii_user}
                  MYSQL_PASSWORD: ${DB_PASSWORD}
                  MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD:-root}
                volumes:
                  - db-data:/var/lib/mysql
                healthcheck:
                  test: ["CMD", "mysqladmin", "ping", "-h", "127.0.0.1", "-p${DB_ROOT_PASSWORD:-root}"]
                  interval: 10s
                  timeout: 5s
                  retries: 6
                  start_period: 30s

            volumes:
              storage:
              logs:
              bootstrap-cache:
              db-data:
            COMPOSEEOF
            # Expand variables in docker-compose.yml
            sed -i "s|\${REGISTRY_IMAGE}:${IMAGE_TAG}|${REGISTRY_IMAGE}:${IMAGE_TAG}|g" docker-compose.yml
            sed -i "s|\${APP_PORT:-8081}|${APP_PORT:-8081}|g" docker-compose.yml
            sed -i "s|\${DB_DATABASE:-koupii_production}|${DB_DATABASE:-koupii_production}|g" docker-compose.yml
            sed -i "s|\${DB_USERNAME:-koupii_user}|${DB_USERNAME:-koupii_user}|g" docker-compose.yml
            sed -i "s|\${DB_PASSWORD}|${DB_PASSWORD}|g" docker-compose.yml
            sed -i "s|\${DB_ROOT_PASSWORD:-root}|${DB_ROOT_PASSWORD:-root}|g" docker-compose.yml

            if docker compose version >/dev/null 2>&1; then
              COMPOSE="docker compose"
            else
              COMPOSE="docker-compose"
            fi

            eval "$COMPOSE pull"
            eval "$COMPOSE up -d --remove-orphans"
            
            # Wait for MySQL to be ready
            echo "Waiting for MySQL to be ready..."
            sleep 25
            
            # Extract database credentials
            DB_NAME=$(grep '^DB_DATABASE=' .env | cut -d'=' -f2)
            DB_USER=$(grep '^DB_USERNAME=' .env | cut -d'=' -f2)
            DB_PASS=$(grep '^DB_PASSWORD=' .env | cut -d'=' -f2-)
            DB_ROOT_PASS=$(grep '^DB_ROOT_PASSWORD=' .env | cut -d'=' -f2-)
            
            if [ -z "$DB_ROOT_PASS" ]; then
              DB_ROOT_PASS="root"
            fi
            
            # Detect actual MySQL root password
            ACTUAL_ROOT_PASS=""
            for TRY_PASS in "root" "$DB_ROOT_PASS"; do
              TEST_RESULT=$(eval "$COMPOSE exec -T mysql mysql -uroot -p\"${TRY_PASS}\" -e 'SELECT 1;' 2>&1" || echo "ERROR")
              if echo "$TEST_RESULT" | grep -qv "ERROR\|Access denied"; then
                ACTUAL_ROOT_PASS="$TRY_PASS"
                break
              fi
            done
            
            if [ -z "$ACTUAL_ROOT_PASS" ]; then
              ACTUAL_ROOT_PASS="$DB_ROOT_PASS"
            else
              DB_ROOT_PASS="$ACTUAL_ROOT_PASS"
            fi
            
            # Setup MySQL user if needed
            CONNECTION_OUTPUT=$(eval "$COMPOSE exec -T mysql mysql -u${DB_USER} -p${DB_PASS} -e 'SELECT 1;' 2>&1" || echo "ERROR")
            
            if echo "$CONNECTION_OUTPUT" | grep -qiE "Access denied|ERROR 1045|ERROR"; then
              echo "Setting up MySQL user with Docker network permissions..."
              SQL_FILE=$(mktemp)
              echo "CREATE DATABASE IF NOT EXISTS \`${DB_NAME}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" > "$SQL_FILE"
              echo "CREATE USER IF NOT EXISTS '${DB_USER}'@'%' IDENTIFIED BY '${DB_PASS}';" >> "$SQL_FILE"
              echo "GRANT ALL PRIVILEGES ON \`${DB_NAME}\`.* TO '${DB_USER}'@'%';" >> "$SQL_FILE"
              echo "FLUSH PRIVILEGES;" >> "$SQL_FILE"
              eval "$COMPOSE exec -T mysql mysql -uroot -p'${DB_ROOT_PASS}' < $SQL_FILE" 2>&1 | grep -v 'Warning' || echo 'User setup completed'
              rm -f "$SQL_FILE"
              sleep 3
            else
              echo "User ${DB_USER} can connect - OK"
            fi
            
            # Fix storage permissions
            eval "$COMPOSE exec -T -u root backend chown -R www-data:www-data /var/www/html/storage"
            eval "$COMPOSE exec -T -u root backend chown -R www-data:www-data /var/www/html/bootstrap/cache"
            eval "$COMPOSE exec -T -u root backend chown -R www-data:www-data /var/www/html/public"

            eval "$COMPOSE exec -T backend php artisan migrate --force"
            eval "$COMPOSE exec -T backend php artisan storage:link" || true
            eval "$COMPOSE exec -T backend php artisan optimize"
            eval "$COMPOSE exec -T backend php artisan config:cache"
            eval "$COMPOSE exec -T backend php artisan route:cache"

            docker logout ghcr.io || true
            # Cleanup docker config
            rm -rf .docker

      - name: Cleanup old env backup
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.SSH_HOST_STAGING }}
          username: ${{ secrets.SSH_USER_STAGING }}
          key: ${{ secrets.SSH_KEY_STAGING }}
          script: |
            cd /srv/apps/koupii-backend || exit 0
            rm -f .env.backup

